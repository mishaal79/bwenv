use anyhow::{Context, Result};
use std::collections::HashMap;
use std::fs::{File, OpenOptions};
use std::io::{BufRead, BufReader, Write};
use std::path::Path;

/// Reads a .env file and returns a HashMap of environment variables
pub fn read_env_file<P: AsRef<Path>>(path: P) -> Result<HashMap<String, String>> {
    let file = File::open(path.as_ref())
        .with_context(|| format!("Failed to open .env file: {:?}", path.as_ref()))?;

    let reader = BufReader::new(file);
    let mut env_vars = HashMap::new();

    for (line_num, line_result) in reader.lines().enumerate() {
        let line = line_result
            .with_context(|| format!("Error reading line {} from .env file", line_num + 1))?;

        // Skip empty lines and comments
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with('#') {
            continue;
        }

        // Parse KEY=VALUE format
        if let Some(pos) = line.find('=') {
            let key = line[..pos].trim().to_string();
            let value = line[pos + 1..].trim().to_string();

            // Don't add empty keys
            if !key.is_empty() {
                env_vars.insert(key, value);
            }
        }
    }

    Ok(env_vars)
}

/// Writes environment variables to a .env file
pub fn write_env_file<P: AsRef<Path>>(
    path: P,
    env_vars: &HashMap<String, String>,
    merge: bool,
) -> Result<()> {
    let mut existing_vars = if merge && path.as_ref().exists() {
        read_env_file(&path)?
    } else {
        HashMap::new()
    };

    // Merge or overwrite with new values
    for (key, value) in env_vars {
        existing_vars.insert(key.clone(), value.clone());
    }

    // Create or truncate the file
    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open(path.as_ref())
        .with_context(|| format!("Failed to open .env file for writing: {:?}", path.as_ref()))?;

    // Write header
    writeln!(file, "# Environment variables")?;
    writeln!(file, "# Generated by bwenv")?;
    writeln!(file, "# {}", chrono::Local::now().to_rfc3339())?;
    writeln!(file)?;

    // Write each key-value pair
    let mut keys: Vec<_> = existing_vars.keys().collect();
    keys.sort(); // Sort keys for consistent output

    for key in keys {
        if let Some(value) = existing_vars.get(key) {
            writeln!(file, "{}={}", key, value)?;
        }
    }

    Ok(())
}

/// Validates a .env file format
pub fn validate_env_file<P: AsRef<Path>>(path: P) -> Result<()> {
    let file = File::open(path.as_ref())
        .with_context(|| format!("Failed to open .env file: {:?}", path.as_ref()))?;

    let reader = BufReader::new(file);

    for (line_num, line_result) in reader.lines().enumerate() {
        let line = line_result
            .with_context(|| format!("Error reading line {} from .env file", line_num + 1))?;

        // Skip empty lines and comments
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with('#') {
            continue;
        }

        // Check for KEY=VALUE format
        if !line.contains('=') {
            return Err(anyhow::anyhow!(
                "Invalid format at line {}: missing '=' character. Expected KEY=VALUE format.",
                line_num + 1
            ));
        }

        // Check for empty key
        if line.starts_with('=') {
            return Err(anyhow::anyhow!(
                "Invalid format at line {}: empty key name. Expected KEY=VALUE format.",
                line_num + 1
            ));
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::tempdir;

    #[test]
    fn test_read_env_file_basic() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("test.env");

        let content = r#"
# This is a comment
DB_HOST=localhost
DB_PORT=5432
API_KEY=secret123

# Another comment
DEBUG=true
"#;
        fs::write(&file_path, content).unwrap();

        let result = read_env_file(&file_path).unwrap();

        assert_eq!(result.get("DB_HOST"), Some(&"localhost".to_string()));
        assert_eq!(result.get("DB_PORT"), Some(&"5432".to_string()));
        assert_eq!(result.get("API_KEY"), Some(&"secret123".to_string()));
        assert_eq!(result.get("DEBUG"), Some(&"true".to_string()));
        assert_eq!(result.len(), 4);
    }

    #[test]
    fn test_read_env_file_with_spaces() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("test.env");

        let content = r#"
KEY1 = value1
KEY2= value2  
KEY3 =value3
KEY4=value4
"#;
        fs::write(&file_path, content).unwrap();

        let result = read_env_file(&file_path).unwrap();

        assert_eq!(result.get("KEY1"), Some(&"value1".to_string()));
        assert_eq!(result.get("KEY2"), Some(&"value2".to_string()));
        assert_eq!(result.get("KEY3"), Some(&"value3".to_string()));
        assert_eq!(result.get("KEY4"), Some(&"value4".to_string()));
    }

    #[test]
    fn test_read_env_file_empty_lines_and_comments() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("test.env");

        let content = r#"
# Header comment

KEY1=value1

# Middle comment

KEY2=value2

"#;
        fs::write(&file_path, content).unwrap();

        let result = read_env_file(&file_path).unwrap();

        assert_eq!(result.len(), 2);
        assert_eq!(result.get("KEY1"), Some(&"value1".to_string()));
        assert_eq!(result.get("KEY2"), Some(&"value2".to_string()));
    }

    #[test]
    fn test_read_env_file_with_empty_values() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("test.env");

        let content = r#"
KEY1=
KEY2=value2
KEY3=
"#;
        fs::write(&file_path, content).unwrap();

        let result = read_env_file(&file_path).unwrap();

        assert_eq!(result.get("KEY1"), Some(&"".to_string()));
        assert_eq!(result.get("KEY2"), Some(&"value2".to_string()));
        assert_eq!(result.get("KEY3"), Some(&"".to_string()));
    }

    #[test]
    fn test_read_env_file_ignores_empty_keys() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("test.env");

        let content = r#"
=value1
KEY2=value2
 =value3
"#;
        fs::write(&file_path, content).unwrap();

        let result = read_env_file(&file_path).unwrap();

        assert_eq!(result.len(), 1);
        assert_eq!(result.get("KEY2"), Some(&"value2".to_string()));
    }

    #[test]
    fn test_read_env_file_nonexistent() {
        let result = read_env_file("/nonexistent/path/file.env");
        assert!(result.is_err());
    }

    #[test]
    fn test_write_env_file_basic() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("output.env");

        let mut env_vars = HashMap::new();
        env_vars.insert("DB_HOST".to_string(), "localhost".to_string());
        env_vars.insert("DB_PORT".to_string(), "5432".to_string());
        env_vars.insert("API_KEY".to_string(), "secret123".to_string());

        write_env_file(&file_path, &env_vars, false).unwrap();

        let content = fs::read_to_string(&file_path).unwrap();
        assert!(content.contains("DB_HOST=localhost"));
        assert!(content.contains("DB_PORT=5432"));
        assert!(content.contains("API_KEY=secret123"));
        assert!(content.contains("# Environment variables"));
        assert!(content.contains("# Generated by bwenv"));
    }

    #[test]
    fn test_write_env_file_sorted_output() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("output.env");

        let mut env_vars = HashMap::new();
        env_vars.insert("ZEBRA".to_string(), "last".to_string());
        env_vars.insert("ALPHA".to_string(), "first".to_string());
        env_vars.insert("BETA".to_string(), "second".to_string());

        write_env_file(&file_path, &env_vars, false).unwrap();

        let content = fs::read_to_string(&file_path).unwrap();
        let lines: Vec<&str> = content.lines().collect();

        // Find the actual key=value lines
        let key_lines: Vec<&str> = lines
            .iter()
            .filter(|line| line.contains('=') && !line.starts_with('#'))
            .copied()
            .collect();

        assert_eq!(key_lines[0], "ALPHA=first");
        assert_eq!(key_lines[1], "BETA=second");
        assert_eq!(key_lines[2], "ZEBRA=last");
    }

    #[test]
    fn test_write_env_file_merge_false() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("output.env");

        // Create initial file
        let initial_content = r#"
EXISTING_KEY=existing_value
SHARED_KEY=old_value
"#;
        fs::write(&file_path, initial_content).unwrap();

        // Write new content without merge
        let mut env_vars = HashMap::new();
        env_vars.insert("NEW_KEY".to_string(), "new_value".to_string());
        env_vars.insert("SHARED_KEY".to_string(), "new_value".to_string());

        write_env_file(&file_path, &env_vars, false).unwrap();

        let content = fs::read_to_string(&file_path).unwrap();
        assert!(content.contains("NEW_KEY=new_value"));
        assert!(content.contains("SHARED_KEY=new_value"));
        assert!(!content.contains("EXISTING_KEY=existing_value"));
    }

    #[test]
    fn test_write_env_file_merge_true() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("output.env");

        // Create initial file
        let initial_content = r#"
EXISTING_KEY=existing_value
SHARED_KEY=old_value
"#;
        fs::write(&file_path, initial_content).unwrap();

        // Write new content with merge
        let mut env_vars = HashMap::new();
        env_vars.insert("NEW_KEY".to_string(), "new_value".to_string());
        env_vars.insert("SHARED_KEY".to_string(), "new_value".to_string());

        write_env_file(&file_path, &env_vars, true).unwrap();

        let content = fs::read_to_string(&file_path).unwrap();
        assert!(content.contains("NEW_KEY=new_value"));
        assert!(content.contains("SHARED_KEY=new_value")); // Should be overwritten
        assert!(content.contains("EXISTING_KEY=existing_value")); // Should be preserved
    }

    #[test]
    fn test_validate_env_file_valid() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("test.env");

        let content = r#"
# Valid .env file
KEY1=value1
KEY2=value2
KEY3=

# Comment
KEY4=value4
"#;
        fs::write(&file_path, content).unwrap();

        let result = validate_env_file(&file_path);
        assert!(result.is_ok());
    }

    #[test]
    fn test_validate_env_file_missing_equals() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("test.env");

        let content = r#"
KEY1=value1
INVALID_LINE_NO_EQUALS
KEY2=value2
"#;
        fs::write(&file_path, content).unwrap();

        let result = validate_env_file(&file_path);
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("missing '=' character"));
    }

    #[test]
    fn test_validate_env_file_empty_key() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("test.env");

        let content = r#"
KEY1=value1
=value_with_empty_key
KEY2=value2
"#;
        fs::write(&file_path, content).unwrap();

        let result = validate_env_file(&file_path);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("empty key name"));
    }

    #[test]
    fn test_validate_env_file_with_comments_and_empty_lines() {
        let temp_dir = tempdir().unwrap();
        let file_path = temp_dir.path().join("test.env");

        let content = r#"
# This is a comment

KEY1=value1

# Another comment

KEY2=value2

"#;
        fs::write(&file_path, content).unwrap();

        let result = validate_env_file(&file_path);
        assert!(result.is_ok());
    }

    #[test]
    fn test_validate_env_file_nonexistent() {
        let result = validate_env_file("/nonexistent/path/file.env");
        assert!(result.is_err());
    }
}
