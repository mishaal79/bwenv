//! Test fixtures and builders
//!
//! Provides builder pattern for constructing test data and predefined fixtures

use bwenv::bitwarden::{MockProvider, Project, Secret};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use tempfile::TempDir;

/// Builder for creating .env files in tests
pub struct EnvFileBuilder {
    entries: HashMap<String, String>,
    include_header: bool,
    temp_dir: Option<TempDir>,
}

impl EnvFileBuilder {
    /// Create a new EnvFileBuilder
    pub fn new() -> Self {
        Self {
            entries: HashMap::new(),
            include_header: true,
            temp_dir: None,
        }
    }

    /// Add an entry to the .env file
    pub fn entry(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.entries.insert(key.into(), value.into());
        self
    }

    /// Add multiple entries at once
    pub fn entries(mut self, entries: HashMap<String, String>) -> Self {
        self.entries.extend(entries);
        self
    }

    /// Control whether to include the header comments
    pub fn with_header(mut self, include: bool) -> Self {
        self.include_header = include;
        self
    }

    /// Build the .env file in a temporary directory
    pub fn build_temp(mut self) -> Result<(PathBuf, TempDir), std::io::Error> {
        let temp_dir = tempfile::tempdir()?;
        let file_path = temp_dir.path().join(".env");
        self.write_to_file(&file_path)?;
        Ok((file_path, temp_dir))
    }

    /// Build the .env file at a specific path
    pub fn build_at(self, path: impl AsRef<Path>) -> Result<PathBuf, std::io::Error> {
        let path = path.as_ref();
        self.write_to_file(path)?;
        Ok(path.to_path_buf())
    }

    /// Write the .env file content
    fn write_to_file(&self, path: &Path) -> Result<(), std::io::Error> {
        use std::io::Write;
        let mut file = std::fs::File::create(path)?;

        if self.include_header {
            writeln!(file, "# Environment variables")?;
            writeln!(file, "# Generated by bwenv test")?;
            writeln!(file)?;
        }

        // Sort keys for consistent output
        let mut keys: Vec<_> = self.entries.keys().collect();
        keys.sort();

        for key in keys {
            if let Some(value) = self.entries.get(key) {
                writeln!(file, "{}={}", key, value)?;
            }
        }

        Ok(())
    }

    /// Get the content as a string
    pub fn to_string(&self) -> String {
        let mut content = String::new();

        if self.include_header {
            content.push_str("# Environment variables\n");
            content.push_str("# Generated by bwenv test\n");
            content.push('\n');
        }

        let mut keys: Vec<_> = self.entries.keys().collect();
        keys.sort();

        for key in keys {
            if let Some(value) = self.entries.get(key) {
                content.push_str(&format!("{}={}\n", key, value));
            }
        }

        content
    }
}

impl Default for EnvFileBuilder {
    fn default() -> Self {
        Self::new()
    }
}

/// Test project fixture with predefined data
pub struct TestProject {
    pub project: Project,
    pub secrets: Vec<Secret>,
    pub provider: MockProvider,
}

impl TestProject {
    /// Create a new test project with default data
    pub fn new(name: &str) -> Self {
        let project = Project {
            id: format!("proj_{}", uuid::Uuid::new_v4()),
            name: name.to_string(),
            organization_id: "org_test".to_string(),
        };

        let provider = MockProvider::new();
        provider.add_project(project.clone());

        Self {
            project,
            secrets: Vec::new(),
            provider,
        }
    }

    /// Add a secret to the test project
    pub fn with_secret(mut self, key: &str, value: &str) -> Self {
        let secret = Secret {
            id: format!("sec_{}", uuid::Uuid::new_v4()),
            key: key.to_string(),
            value: value.to_string(),
            note: None,
            project_id: self.project.id.clone(),
        };

        self.provider.add_secret(secret.clone());
        self.secrets.push(secret);
        self
    }

    /// Add multiple secrets at once
    pub fn with_secrets(mut self, secrets: HashMap<String, String>) -> Self {
        for (key, value) in secrets {
            self = self.with_secret(&key, &value);
        }
        self
    }

    /// Get the provider
    pub fn provider(&self) -> &MockProvider {
        &self.provider
    }

    /// Get the project
    pub fn project(&self) -> &Project {
        &self.project
    }
}

// Predefined fixtures using const strings
pub const SIMPLE_ENV: &str = r#"
# Simple environment
DB_HOST=localhost
DB_PORT=5432
API_KEY=test123
"#;

pub const COMPLEX_ENV: &str = r#"
# Database configuration
DB_HOST=localhost
DB_PORT=5432
DB_NAME=myapp
DB_USER=admin
DB_PASSWORD=secure_password

# API configuration
API_KEY=sk_test_1234567890
API_URL=https://api.example.com
API_TIMEOUT=30

# Feature flags
FEATURE_NEW_UI=true
FEATURE_ANALYTICS=false
DEBUG_MODE=true
"#;

pub const EMPTY_VALUES_ENV: &str = r#"
KEY1=
KEY2=value2
KEY3=
"#;

pub const MULTILINE_ENV: &str = r#"
# Header comment

KEY1=value1

# Middle comment

KEY2=value2

"#;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_env_file_builder_simple() {
        let builder = EnvFileBuilder::new()
            .entry("KEY1", "value1")
            .entry("KEY2", "value2");

        let content = builder.to_string();
        assert!(content.contains("KEY1=value1"));
        assert!(content.contains("KEY2=value2"));
    }

    #[test]
    fn test_env_file_builder_no_header() {
        let builder = EnvFileBuilder::new()
            .with_header(false)
            .entry("KEY1", "value1");

        let content = builder.to_string();
        assert!(!content.contains("# Environment variables"));
        assert!(content.contains("KEY1=value1"));
    }

    #[test]
    fn test_env_file_builder_sorted_output() {
        let builder = EnvFileBuilder::new()
            .with_header(false)
            .entry("ZEBRA", "last")
            .entry("ALPHA", "first")
            .entry("BETA", "second");

        let content = builder.to_string();
        let lines: Vec<&str> = content.lines().collect();

        assert_eq!(lines[0], "ALPHA=first");
        assert_eq!(lines[1], "BETA=second");
        assert_eq!(lines[2], "ZEBRA=last");
    }

    #[test]
    fn test_env_file_builder_temp() {
        let (path, _temp_dir) = EnvFileBuilder::new()
            .entry("KEY1", "value1")
            .build_temp()
            .unwrap();

        assert!(path.exists());
        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("KEY1=value1"));
    }

    #[tokio::test]
    async fn test_test_project_creation() {
        let project = TestProject::new("Test Project");
        assert_eq!(project.project.name, "Test Project");

        let projects = project.provider.list_projects().await.unwrap();
        assert_eq!(projects.len(), 1);
    }

    #[tokio::test]
    async fn test_test_project_with_secrets() {
        let project = TestProject::new("Test Project")
            .with_secret("KEY1", "value1")
            .with_secret("KEY2", "value2");

        let secrets = project.provider.list_secrets(&project.project.id).await.unwrap();
        assert_eq!(secrets.len(), 2);
    }

    #[tokio::test]
    async fn test_test_project_with_secrets_map() {
        let mut secrets_map = HashMap::new();
        secrets_map.insert("KEY1".to_string(), "value1".to_string());
        secrets_map.insert("KEY2".to_string(), "value2".to_string());

        let project = TestProject::new("Test Project").with_secrets(secrets_map);

        let secrets = project.provider.list_secrets(&project.project.id).await.unwrap();
        assert_eq!(secrets.len(), 2);
    }
}
